// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// CanSendStoryResultOk represents TL type `canSendStoryResultOk#503cf0fd`.
type CanSendStoryResultOk struct {
}

// CanSendStoryResultOkTypeID is TL type id of CanSendStoryResultOk.
const CanSendStoryResultOkTypeID = 0x503cf0fd

// construct implements constructor of CanSendStoryResultClass.
func (c CanSendStoryResultOk) construct() CanSendStoryResultClass { return &c }

// Ensuring interfaces in compile-time for CanSendStoryResultOk.
var (
	_ bin.Encoder     = &CanSendStoryResultOk{}
	_ bin.Decoder     = &CanSendStoryResultOk{}
	_ bin.BareEncoder = &CanSendStoryResultOk{}
	_ bin.BareDecoder = &CanSendStoryResultOk{}

	_ CanSendStoryResultClass = &CanSendStoryResultOk{}
)

func (c *CanSendStoryResultOk) Zero() bool {
	if c == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (c *CanSendStoryResultOk) String() string {
	if c == nil {
		return "CanSendStoryResultOk(nil)"
	}
	type Alias CanSendStoryResultOk
	return fmt.Sprintf("CanSendStoryResultOk%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*CanSendStoryResultOk) TypeID() uint32 {
	return CanSendStoryResultOkTypeID
}

// TypeName returns name of type in TL schema.
func (*CanSendStoryResultOk) TypeName() string {
	return "canSendStoryResultOk"
}

// TypeInfo returns info about TL type.
func (c *CanSendStoryResultOk) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "canSendStoryResultOk",
		ID:   CanSendStoryResultOkTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (c *CanSendStoryResultOk) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultOk#503cf0fd as nil")
	}
	b.PutID(CanSendStoryResultOkTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *CanSendStoryResultOk) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultOk#503cf0fd as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *CanSendStoryResultOk) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultOk#503cf0fd to nil")
	}
	if err := b.ConsumeID(CanSendStoryResultOkTypeID); err != nil {
		return fmt.Errorf("unable to decode canSendStoryResultOk#503cf0fd: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *CanSendStoryResultOk) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultOk#503cf0fd to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *CanSendStoryResultOk) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultOk#503cf0fd as nil")
	}
	b.ObjStart()
	b.PutID("canSendStoryResultOk")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *CanSendStoryResultOk) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultOk#503cf0fd to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("canSendStoryResultOk"); err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultOk#503cf0fd: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// CanSendStoryResultPremiumNeeded represents TL type `canSendStoryResultPremiumNeeded#567fde69`.
type CanSendStoryResultPremiumNeeded struct {
}

// CanSendStoryResultPremiumNeededTypeID is TL type id of CanSendStoryResultPremiumNeeded.
const CanSendStoryResultPremiumNeededTypeID = 0x567fde69

// construct implements constructor of CanSendStoryResultClass.
func (c CanSendStoryResultPremiumNeeded) construct() CanSendStoryResultClass { return &c }

// Ensuring interfaces in compile-time for CanSendStoryResultPremiumNeeded.
var (
	_ bin.Encoder     = &CanSendStoryResultPremiumNeeded{}
	_ bin.Decoder     = &CanSendStoryResultPremiumNeeded{}
	_ bin.BareEncoder = &CanSendStoryResultPremiumNeeded{}
	_ bin.BareDecoder = &CanSendStoryResultPremiumNeeded{}

	_ CanSendStoryResultClass = &CanSendStoryResultPremiumNeeded{}
)

func (c *CanSendStoryResultPremiumNeeded) Zero() bool {
	if c == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (c *CanSendStoryResultPremiumNeeded) String() string {
	if c == nil {
		return "CanSendStoryResultPremiumNeeded(nil)"
	}
	type Alias CanSendStoryResultPremiumNeeded
	return fmt.Sprintf("CanSendStoryResultPremiumNeeded%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*CanSendStoryResultPremiumNeeded) TypeID() uint32 {
	return CanSendStoryResultPremiumNeededTypeID
}

// TypeName returns name of type in TL schema.
func (*CanSendStoryResultPremiumNeeded) TypeName() string {
	return "canSendStoryResultPremiumNeeded"
}

// TypeInfo returns info about TL type.
func (c *CanSendStoryResultPremiumNeeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "canSendStoryResultPremiumNeeded",
		ID:   CanSendStoryResultPremiumNeededTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (c *CanSendStoryResultPremiumNeeded) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultPremiumNeeded#567fde69 as nil")
	}
	b.PutID(CanSendStoryResultPremiumNeededTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *CanSendStoryResultPremiumNeeded) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultPremiumNeeded#567fde69 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *CanSendStoryResultPremiumNeeded) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultPremiumNeeded#567fde69 to nil")
	}
	if err := b.ConsumeID(CanSendStoryResultPremiumNeededTypeID); err != nil {
		return fmt.Errorf("unable to decode canSendStoryResultPremiumNeeded#567fde69: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *CanSendStoryResultPremiumNeeded) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultPremiumNeeded#567fde69 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *CanSendStoryResultPremiumNeeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultPremiumNeeded#567fde69 as nil")
	}
	b.ObjStart()
	b.PutID("canSendStoryResultPremiumNeeded")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *CanSendStoryResultPremiumNeeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultPremiumNeeded#567fde69 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("canSendStoryResultPremiumNeeded"); err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultPremiumNeeded#567fde69: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// CanSendStoryResultBoostNeeded represents TL type `canSendStoryResultBoostNeeded#9e60e92f`.
type CanSendStoryResultBoostNeeded struct {
}

// CanSendStoryResultBoostNeededTypeID is TL type id of CanSendStoryResultBoostNeeded.
const CanSendStoryResultBoostNeededTypeID = 0x9e60e92f

// construct implements constructor of CanSendStoryResultClass.
func (c CanSendStoryResultBoostNeeded) construct() CanSendStoryResultClass { return &c }

// Ensuring interfaces in compile-time for CanSendStoryResultBoostNeeded.
var (
	_ bin.Encoder     = &CanSendStoryResultBoostNeeded{}
	_ bin.Decoder     = &CanSendStoryResultBoostNeeded{}
	_ bin.BareEncoder = &CanSendStoryResultBoostNeeded{}
	_ bin.BareDecoder = &CanSendStoryResultBoostNeeded{}

	_ CanSendStoryResultClass = &CanSendStoryResultBoostNeeded{}
)

func (c *CanSendStoryResultBoostNeeded) Zero() bool {
	if c == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (c *CanSendStoryResultBoostNeeded) String() string {
	if c == nil {
		return "CanSendStoryResultBoostNeeded(nil)"
	}
	type Alias CanSendStoryResultBoostNeeded
	return fmt.Sprintf("CanSendStoryResultBoostNeeded%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*CanSendStoryResultBoostNeeded) TypeID() uint32 {
	return CanSendStoryResultBoostNeededTypeID
}

// TypeName returns name of type in TL schema.
func (*CanSendStoryResultBoostNeeded) TypeName() string {
	return "canSendStoryResultBoostNeeded"
}

// TypeInfo returns info about TL type.
func (c *CanSendStoryResultBoostNeeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "canSendStoryResultBoostNeeded",
		ID:   CanSendStoryResultBoostNeededTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (c *CanSendStoryResultBoostNeeded) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultBoostNeeded#9e60e92f as nil")
	}
	b.PutID(CanSendStoryResultBoostNeededTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *CanSendStoryResultBoostNeeded) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultBoostNeeded#9e60e92f as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *CanSendStoryResultBoostNeeded) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultBoostNeeded#9e60e92f to nil")
	}
	if err := b.ConsumeID(CanSendStoryResultBoostNeededTypeID); err != nil {
		return fmt.Errorf("unable to decode canSendStoryResultBoostNeeded#9e60e92f: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *CanSendStoryResultBoostNeeded) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultBoostNeeded#9e60e92f to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *CanSendStoryResultBoostNeeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultBoostNeeded#9e60e92f as nil")
	}
	b.ObjStart()
	b.PutID("canSendStoryResultBoostNeeded")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *CanSendStoryResultBoostNeeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultBoostNeeded#9e60e92f to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("canSendStoryResultBoostNeeded"); err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultBoostNeeded#9e60e92f: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// CanSendStoryResultActiveStoryLimitExceeded represents TL type `canSendStoryResultActiveStoryLimitExceeded#afd9aad6`.
type CanSendStoryResultActiveStoryLimitExceeded struct {
}

// CanSendStoryResultActiveStoryLimitExceededTypeID is TL type id of CanSendStoryResultActiveStoryLimitExceeded.
const CanSendStoryResultActiveStoryLimitExceededTypeID = 0xafd9aad6

// construct implements constructor of CanSendStoryResultClass.
func (c CanSendStoryResultActiveStoryLimitExceeded) construct() CanSendStoryResultClass { return &c }

// Ensuring interfaces in compile-time for CanSendStoryResultActiveStoryLimitExceeded.
var (
	_ bin.Encoder     = &CanSendStoryResultActiveStoryLimitExceeded{}
	_ bin.Decoder     = &CanSendStoryResultActiveStoryLimitExceeded{}
	_ bin.BareEncoder = &CanSendStoryResultActiveStoryLimitExceeded{}
	_ bin.BareDecoder = &CanSendStoryResultActiveStoryLimitExceeded{}

	_ CanSendStoryResultClass = &CanSendStoryResultActiveStoryLimitExceeded{}
)

func (c *CanSendStoryResultActiveStoryLimitExceeded) Zero() bool {
	if c == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (c *CanSendStoryResultActiveStoryLimitExceeded) String() string {
	if c == nil {
		return "CanSendStoryResultActiveStoryLimitExceeded(nil)"
	}
	type Alias CanSendStoryResultActiveStoryLimitExceeded
	return fmt.Sprintf("CanSendStoryResultActiveStoryLimitExceeded%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*CanSendStoryResultActiveStoryLimitExceeded) TypeID() uint32 {
	return CanSendStoryResultActiveStoryLimitExceededTypeID
}

// TypeName returns name of type in TL schema.
func (*CanSendStoryResultActiveStoryLimitExceeded) TypeName() string {
	return "canSendStoryResultActiveStoryLimitExceeded"
}

// TypeInfo returns info about TL type.
func (c *CanSendStoryResultActiveStoryLimitExceeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "canSendStoryResultActiveStoryLimitExceeded",
		ID:   CanSendStoryResultActiveStoryLimitExceededTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (c *CanSendStoryResultActiveStoryLimitExceeded) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultActiveStoryLimitExceeded#afd9aad6 as nil")
	}
	b.PutID(CanSendStoryResultActiveStoryLimitExceededTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *CanSendStoryResultActiveStoryLimitExceeded) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultActiveStoryLimitExceeded#afd9aad6 as nil")
	}
	return nil
}

// Decode implements bin.Decoder.
func (c *CanSendStoryResultActiveStoryLimitExceeded) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultActiveStoryLimitExceeded#afd9aad6 to nil")
	}
	if err := b.ConsumeID(CanSendStoryResultActiveStoryLimitExceededTypeID); err != nil {
		return fmt.Errorf("unable to decode canSendStoryResultActiveStoryLimitExceeded#afd9aad6: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *CanSendStoryResultActiveStoryLimitExceeded) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultActiveStoryLimitExceeded#afd9aad6 to nil")
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *CanSendStoryResultActiveStoryLimitExceeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultActiveStoryLimitExceeded#afd9aad6 as nil")
	}
	b.ObjStart()
	b.PutID("canSendStoryResultActiveStoryLimitExceeded")
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *CanSendStoryResultActiveStoryLimitExceeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultActiveStoryLimitExceeded#afd9aad6 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("canSendStoryResultActiveStoryLimitExceeded"); err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultActiveStoryLimitExceeded#afd9aad6: %w", err)
			}
		default:
			return b.Skip()
		}
		return nil
	})
}

// CanSendStoryResultWeeklyLimitExceeded represents TL type `canSendStoryResultWeeklyLimitExceeded#1341a0b8`.
type CanSendStoryResultWeeklyLimitExceeded struct {
	// Time left before the user can send the next story
	RetryAfter int32
}

// CanSendStoryResultWeeklyLimitExceededTypeID is TL type id of CanSendStoryResultWeeklyLimitExceeded.
const CanSendStoryResultWeeklyLimitExceededTypeID = 0x1341a0b8

// construct implements constructor of CanSendStoryResultClass.
func (c CanSendStoryResultWeeklyLimitExceeded) construct() CanSendStoryResultClass { return &c }

// Ensuring interfaces in compile-time for CanSendStoryResultWeeklyLimitExceeded.
var (
	_ bin.Encoder     = &CanSendStoryResultWeeklyLimitExceeded{}
	_ bin.Decoder     = &CanSendStoryResultWeeklyLimitExceeded{}
	_ bin.BareEncoder = &CanSendStoryResultWeeklyLimitExceeded{}
	_ bin.BareDecoder = &CanSendStoryResultWeeklyLimitExceeded{}

	_ CanSendStoryResultClass = &CanSendStoryResultWeeklyLimitExceeded{}
)

func (c *CanSendStoryResultWeeklyLimitExceeded) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.RetryAfter == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *CanSendStoryResultWeeklyLimitExceeded) String() string {
	if c == nil {
		return "CanSendStoryResultWeeklyLimitExceeded(nil)"
	}
	type Alias CanSendStoryResultWeeklyLimitExceeded
	return fmt.Sprintf("CanSendStoryResultWeeklyLimitExceeded%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*CanSendStoryResultWeeklyLimitExceeded) TypeID() uint32 {
	return CanSendStoryResultWeeklyLimitExceededTypeID
}

// TypeName returns name of type in TL schema.
func (*CanSendStoryResultWeeklyLimitExceeded) TypeName() string {
	return "canSendStoryResultWeeklyLimitExceeded"
}

// TypeInfo returns info about TL type.
func (c *CanSendStoryResultWeeklyLimitExceeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "canSendStoryResultWeeklyLimitExceeded",
		ID:   CanSendStoryResultWeeklyLimitExceededTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RetryAfter",
			SchemaName: "retry_after",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *CanSendStoryResultWeeklyLimitExceeded) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultWeeklyLimitExceeded#1341a0b8 as nil")
	}
	b.PutID(CanSendStoryResultWeeklyLimitExceededTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *CanSendStoryResultWeeklyLimitExceeded) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultWeeklyLimitExceeded#1341a0b8 as nil")
	}
	b.PutInt32(c.RetryAfter)
	return nil
}

// Decode implements bin.Decoder.
func (c *CanSendStoryResultWeeklyLimitExceeded) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultWeeklyLimitExceeded#1341a0b8 to nil")
	}
	if err := b.ConsumeID(CanSendStoryResultWeeklyLimitExceededTypeID); err != nil {
		return fmt.Errorf("unable to decode canSendStoryResultWeeklyLimitExceeded#1341a0b8: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *CanSendStoryResultWeeklyLimitExceeded) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultWeeklyLimitExceeded#1341a0b8 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode canSendStoryResultWeeklyLimitExceeded#1341a0b8: field retry_after: %w", err)
		}
		c.RetryAfter = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *CanSendStoryResultWeeklyLimitExceeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultWeeklyLimitExceeded#1341a0b8 as nil")
	}
	b.ObjStart()
	b.PutID("canSendStoryResultWeeklyLimitExceeded")
	b.Comma()
	b.FieldStart("retry_after")
	b.PutInt32(c.RetryAfter)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *CanSendStoryResultWeeklyLimitExceeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultWeeklyLimitExceeded#1341a0b8 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("canSendStoryResultWeeklyLimitExceeded"); err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultWeeklyLimitExceeded#1341a0b8: %w", err)
			}
		case "retry_after":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultWeeklyLimitExceeded#1341a0b8: field retry_after: %w", err)
			}
			c.RetryAfter = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetRetryAfter returns value of RetryAfter field.
func (c *CanSendStoryResultWeeklyLimitExceeded) GetRetryAfter() (value int32) {
	if c == nil {
		return
	}
	return c.RetryAfter
}

// CanSendStoryResultMonthlyLimitExceeded represents TL type `canSendStoryResultMonthlyLimitExceeded#dd8242d5`.
type CanSendStoryResultMonthlyLimitExceeded struct {
	// Time left before the user can send the next story
	RetryAfter int32
}

// CanSendStoryResultMonthlyLimitExceededTypeID is TL type id of CanSendStoryResultMonthlyLimitExceeded.
const CanSendStoryResultMonthlyLimitExceededTypeID = 0xdd8242d5

// construct implements constructor of CanSendStoryResultClass.
func (c CanSendStoryResultMonthlyLimitExceeded) construct() CanSendStoryResultClass { return &c }

// Ensuring interfaces in compile-time for CanSendStoryResultMonthlyLimitExceeded.
var (
	_ bin.Encoder     = &CanSendStoryResultMonthlyLimitExceeded{}
	_ bin.Decoder     = &CanSendStoryResultMonthlyLimitExceeded{}
	_ bin.BareEncoder = &CanSendStoryResultMonthlyLimitExceeded{}
	_ bin.BareDecoder = &CanSendStoryResultMonthlyLimitExceeded{}

	_ CanSendStoryResultClass = &CanSendStoryResultMonthlyLimitExceeded{}
)

func (c *CanSendStoryResultMonthlyLimitExceeded) Zero() bool {
	if c == nil {
		return true
	}
	if !(c.RetryAfter == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (c *CanSendStoryResultMonthlyLimitExceeded) String() string {
	if c == nil {
		return "CanSendStoryResultMonthlyLimitExceeded(nil)"
	}
	type Alias CanSendStoryResultMonthlyLimitExceeded
	return fmt.Sprintf("CanSendStoryResultMonthlyLimitExceeded%+v", Alias(*c))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*CanSendStoryResultMonthlyLimitExceeded) TypeID() uint32 {
	return CanSendStoryResultMonthlyLimitExceededTypeID
}

// TypeName returns name of type in TL schema.
func (*CanSendStoryResultMonthlyLimitExceeded) TypeName() string {
	return "canSendStoryResultMonthlyLimitExceeded"
}

// TypeInfo returns info about TL type.
func (c *CanSendStoryResultMonthlyLimitExceeded) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "canSendStoryResultMonthlyLimitExceeded",
		ID:   CanSendStoryResultMonthlyLimitExceededTypeID,
	}
	if c == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RetryAfter",
			SchemaName: "retry_after",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (c *CanSendStoryResultMonthlyLimitExceeded) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultMonthlyLimitExceeded#dd8242d5 as nil")
	}
	b.PutID(CanSendStoryResultMonthlyLimitExceededTypeID)
	return c.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (c *CanSendStoryResultMonthlyLimitExceeded) EncodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultMonthlyLimitExceeded#dd8242d5 as nil")
	}
	b.PutInt32(c.RetryAfter)
	return nil
}

// Decode implements bin.Decoder.
func (c *CanSendStoryResultMonthlyLimitExceeded) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultMonthlyLimitExceeded#dd8242d5 to nil")
	}
	if err := b.ConsumeID(CanSendStoryResultMonthlyLimitExceededTypeID); err != nil {
		return fmt.Errorf("unable to decode canSendStoryResultMonthlyLimitExceeded#dd8242d5: %w", err)
	}
	return c.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (c *CanSendStoryResultMonthlyLimitExceeded) DecodeBare(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultMonthlyLimitExceeded#dd8242d5 to nil")
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode canSendStoryResultMonthlyLimitExceeded#dd8242d5: field retry_after: %w", err)
		}
		c.RetryAfter = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (c *CanSendStoryResultMonthlyLimitExceeded) EncodeTDLibJSON(b tdjson.Encoder) error {
	if c == nil {
		return fmt.Errorf("can't encode canSendStoryResultMonthlyLimitExceeded#dd8242d5 as nil")
	}
	b.ObjStart()
	b.PutID("canSendStoryResultMonthlyLimitExceeded")
	b.Comma()
	b.FieldStart("retry_after")
	b.PutInt32(c.RetryAfter)
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (c *CanSendStoryResultMonthlyLimitExceeded) DecodeTDLibJSON(b tdjson.Decoder) error {
	if c == nil {
		return fmt.Errorf("can't decode canSendStoryResultMonthlyLimitExceeded#dd8242d5 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("canSendStoryResultMonthlyLimitExceeded"); err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultMonthlyLimitExceeded#dd8242d5: %w", err)
			}
		case "retry_after":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode canSendStoryResultMonthlyLimitExceeded#dd8242d5: field retry_after: %w", err)
			}
			c.RetryAfter = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetRetryAfter returns value of RetryAfter field.
func (c *CanSendStoryResultMonthlyLimitExceeded) GetRetryAfter() (value int32) {
	if c == nil {
		return
	}
	return c.RetryAfter
}

// CanSendStoryResultClassName is schema name of CanSendStoryResultClass.
const CanSendStoryResultClassName = "CanSendStoryResult"

// CanSendStoryResultClass represents CanSendStoryResult generic type.
//
// Example:
//
//	g, err := tdapi.DecodeCanSendStoryResult(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *tdapi.CanSendStoryResultOk: // canSendStoryResultOk#503cf0fd
//	case *tdapi.CanSendStoryResultPremiumNeeded: // canSendStoryResultPremiumNeeded#567fde69
//	case *tdapi.CanSendStoryResultBoostNeeded: // canSendStoryResultBoostNeeded#9e60e92f
//	case *tdapi.CanSendStoryResultActiveStoryLimitExceeded: // canSendStoryResultActiveStoryLimitExceeded#afd9aad6
//	case *tdapi.CanSendStoryResultWeeklyLimitExceeded: // canSendStoryResultWeeklyLimitExceeded#1341a0b8
//	case *tdapi.CanSendStoryResultMonthlyLimitExceeded: // canSendStoryResultMonthlyLimitExceeded#dd8242d5
//	default: panic(v)
//	}
type CanSendStoryResultClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() CanSendStoryResultClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	EncodeTDLibJSON(b tdjson.Encoder) error
	DecodeTDLibJSON(b tdjson.Decoder) error
}

// DecodeCanSendStoryResult implements binary de-serialization for CanSendStoryResultClass.
func DecodeCanSendStoryResult(buf *bin.Buffer) (CanSendStoryResultClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case CanSendStoryResultOkTypeID:
		// Decoding canSendStoryResultOk#503cf0fd.
		v := CanSendStoryResultOk{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case CanSendStoryResultPremiumNeededTypeID:
		// Decoding canSendStoryResultPremiumNeeded#567fde69.
		v := CanSendStoryResultPremiumNeeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case CanSendStoryResultBoostNeededTypeID:
		// Decoding canSendStoryResultBoostNeeded#9e60e92f.
		v := CanSendStoryResultBoostNeeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case CanSendStoryResultActiveStoryLimitExceededTypeID:
		// Decoding canSendStoryResultActiveStoryLimitExceeded#afd9aad6.
		v := CanSendStoryResultActiveStoryLimitExceeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case CanSendStoryResultWeeklyLimitExceededTypeID:
		// Decoding canSendStoryResultWeeklyLimitExceeded#1341a0b8.
		v := CanSendStoryResultWeeklyLimitExceeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case CanSendStoryResultMonthlyLimitExceededTypeID:
		// Decoding canSendStoryResultMonthlyLimitExceeded#dd8242d5.
		v := CanSendStoryResultMonthlyLimitExceeded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", bin.NewUnexpectedID(id))
	}
}

// DecodeTDLibJSONCanSendStoryResult implements binary de-serialization for CanSendStoryResultClass.
func DecodeTDLibJSONCanSendStoryResult(buf tdjson.Decoder) (CanSendStoryResultClass, error) {
	id, err := buf.FindTypeID()
	if err != nil {
		return nil, err
	}
	switch id {
	case "canSendStoryResultOk":
		// Decoding canSendStoryResultOk#503cf0fd.
		v := CanSendStoryResultOk{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case "canSendStoryResultPremiumNeeded":
		// Decoding canSendStoryResultPremiumNeeded#567fde69.
		v := CanSendStoryResultPremiumNeeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case "canSendStoryResultBoostNeeded":
		// Decoding canSendStoryResultBoostNeeded#9e60e92f.
		v := CanSendStoryResultBoostNeeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case "canSendStoryResultActiveStoryLimitExceeded":
		// Decoding canSendStoryResultActiveStoryLimitExceeded#afd9aad6.
		v := CanSendStoryResultActiveStoryLimitExceeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case "canSendStoryResultWeeklyLimitExceeded":
		// Decoding canSendStoryResultWeeklyLimitExceeded#1341a0b8.
		v := CanSendStoryResultWeeklyLimitExceeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	case "canSendStoryResultMonthlyLimitExceeded":
		// Decoding canSendStoryResultMonthlyLimitExceeded#dd8242d5.
		v := CanSendStoryResultMonthlyLimitExceeded{}
		if err := v.DecodeTDLibJSON(buf); err != nil {
			return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode CanSendStoryResultClass: %w", tdjson.NewUnexpectedID(id))
	}
}

// CanSendStoryResult boxes the CanSendStoryResultClass providing a helper.
type CanSendStoryResultBox struct {
	CanSendStoryResult CanSendStoryResultClass
}

// Decode implements bin.Decoder for CanSendStoryResultBox.
func (b *CanSendStoryResultBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode CanSendStoryResultBox to nil")
	}
	v, err := DecodeCanSendStoryResult(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.CanSendStoryResult = v
	return nil
}

// Encode implements bin.Encode for CanSendStoryResultBox.
func (b *CanSendStoryResultBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.CanSendStoryResult == nil {
		return fmt.Errorf("unable to encode CanSendStoryResultClass as nil")
	}
	return b.CanSendStoryResult.Encode(buf)
}

// DecodeTDLibJSON implements bin.Decoder for CanSendStoryResultBox.
func (b *CanSendStoryResultBox) DecodeTDLibJSON(buf tdjson.Decoder) error {
	if b == nil {
		return fmt.Errorf("unable to decode CanSendStoryResultBox to nil")
	}
	v, err := DecodeTDLibJSONCanSendStoryResult(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.CanSendStoryResult = v
	return nil
}

// EncodeTDLibJSON implements bin.Encode for CanSendStoryResultBox.
func (b *CanSendStoryResultBox) EncodeTDLibJSON(buf tdjson.Encoder) error {
	if b == nil || b.CanSendStoryResult == nil {
		return fmt.Errorf("unable to encode CanSendStoryResultClass as nil")
	}
	return b.CanSendStoryResult.EncodeTDLibJSON(buf)
}
